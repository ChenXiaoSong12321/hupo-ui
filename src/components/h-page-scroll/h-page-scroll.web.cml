<template>
  <page title="{{selfTitle}}">
    <view class="h-page h-page--{{background}}" style="height: {{viewportHeight}}px;">
      <h-navbar
        type="{{type}}"
        loading="{{loading}}"
        title="{{selfTitle}}"
        showHomeIcon="{{showHomeIcon}}"
      ></h-navbar>
      <view class="h-page-wrapper" ref="wrapper" style="height: {{scrollHeight}}px">
        <view class="h-page-container" style="min-height: {{scrollHeight + 1}}px">
          <h-dialog ref="h-dialog" c-bind:confirm="dialogConfirm" c-bind:cancel="dialogCancel"></h-dialog>
          <h-toast ref="h-toast"></h-toast>
          <!-- 刷新提示信息 -->
          <view class="h-page-pulldown">
            <h-navbar-loading show></h-navbar-loading>
          </view>
          <!-- 内容 -->
          <view class="h-page-content">
            <slot></slot>
          </view>
          <!-- 底部提示信息 -->
          <view class="h-page-pullup">
            <h-load-more loading="{{status == 'pullup'}}"></h-load-more>
          </view>
        </view>
      </view>
      <view class="h-page-bottom" c-if="{{viewport.isAllScreen}}"></view>
    </view>
  </page>
</template>
<script>
import cml from "chameleon-api";
import BScroll from "better-scroll";
import difference from "../../core/difference/difference.interface";
import HPageMixins from "../h-page/h-page.mixin";
import component from "../../core/mixins/component.js";
class HPageScroll {
  computed = {
    scrollHeight() {
      const subtract = cml.cpx2px(this.subtract);
      const viewportHeight = cml.cpx2px(this.viewport.viewportHeight);
      const bottomHeight = this.viewport.bottomHeight
      return Math.floor( viewportHeight - this.viewport.headerHeight - bottomHeight - subtract );
    }
  };

  watch = {
    async scrollHeight(){
      await difference.nextTick();
      this.scroll && this.scroll.refresh();
    }
  }

  async created() {
    await difference.nextTick();
    this.scroll = new BScroll(this.$refs.wrapper, {
      //初始化better-scroll
      probeType: 1, //1 滚动的时候会派发scroll事件，会截流。2滚动的时候实时派发scroll事件，不会截流。 3除了实时派发scroll事件，在swipe的情况下仍然能实时派发scroll事件
      click: true, //是否派发click事件
      bounce: {
        bottom: true,
        top: true
      },
      pullDownRefresh: {
        threshold: 40,
        stop: 40
      }
    });
    //滑动结束松开事件
    this.scroll.on("touchEnd", pos => {
      if (!!this.status) return;
      if (pos.y > 30) {
        this.status = "pulldown";
        // pulldown refresh
        this.$cmlEmit("pulldown", this);
      } else if (pos.y < this.scroll.maxScrollY + 200) {
        // pullup loading
        this.status = "pullup";
        this.$cmlEmit("pullup", this);
      }
    });
  }

  methods = {
    async stop() {
      this.status = "";
      await difference.nextTick();
      this.scroll && this.scroll.finishPullDown();
      this.scroll && this.scroll.finishPullUp();
      this.scroll && this.scroll.refresh();
    }
  };
}
export default component(HPageMixins, HPageScroll);
</script>
<style lang="scss">
@import "./h-page-scroll.web.scss";
</style>
<script cml-type="json">
{
  "base": {
    "usingComponents": {
      "h-navbar": "../h-navbar/h-navbar",
      "h-navbar-loading": "../h-navbar/components/loading/loading",
      "h-load-more": "../h-load-more/h-load-more",
      "h-toast": "../h-toast/h-toast",
      "h-dialog": "../h-dialog/h-dialog"
    },
    "component": true
  }
}
</script>
